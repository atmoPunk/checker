Данный алгоритм заключается в следующем:

Исходный код программ студентов конкатенируется в один файл:
Сперва идут заголовочные файлы затем файлы с имплементацией
В процессе обхода директивы #include, которые указвыают на 
файлы стандартной библиотеки помечаются специальными маркерами,  // Сейчас помечаются #include <...>
до и после самой директивы

Затем при помощи команды clang -Xclang -ast-dump -fsyntax-only -fno-color-diagnostics -w
строится абстрактное синтаксическое дерево всей программы. Так как clang включает код
из файлов, которые были включены при помощи #include, то он строит дерево из файлов,
входящих в стандартную библиотеку. Нам эти файлы не нужны, поэтому из дерева вырезаются
куски которые были помечены маркерами на прошлом шаге.

Так же из дерева вырезается информация об адресах(?) построенных clang),
о местоположениях в файлах (строки и колонки), и идентификаторах.
Это позволяет сопоставить фрагменты, где например переменная была просто переименнована,
но в то же время теряется часть информации. Для избежания этого можно не просто удалять
информацию о идентификаторах, а заменять её у всех студентов на одинаковые // Ещё не сделано
(Для каждого top-level (узел, который на один уровень ниже TranslationUnitDecl - корень дерева)
узла заменять int a; int b на int int1; int int2; и т.п.
Так как нумерация будет начинаться сначала на каждом top-level узле, то
перестановка местами двух имплементаций функций не помешает нашему анализатору)
Скорее всего это увеличит точность

После всех этих действий для трех, подряд (в том порядке, в котором
их выдает clang) идущих узла дерева строится хэш от их строчного представления
(сейчас используется функция md5), и все эти хэши записываются в словарь и подсчитывается количество
их появлений.

Для сравнения двух работ можно просто сравнить два словаря - посмотреть,
насколько много хэшей они имеют в общем.
Это значение может показать насколько работы похожи, но
оно не учитывает того, что во многих работах существуют куски,
которые будут повторяться всегда, даже если никакого плагиата там нет.

// Еще не сделано
Для избежания этой проблемы можно построить индекс хэшей к работам для 
данного задания. (Для каждого хэша сообщить, в каких файлах он встречается)
Это позволит взвесить хэши, и придавать им меньше значения (если он встречается
почти везде), иди больше (если встречается редко) 
